Random useful syntax:
1. Initializing a vector:
vector<int> _data;
_data({10})

2. Using a templatized node with shared_ptr.
shared_ptr<Node<T>>

3. Numeric limits of basic arithmetic data types
   std::numeric_limits<unsigned>::max()
   std::numeric_limits<unsigned>::min()

4. log10() Gives you number of digits in a decimal number
e.g. log (100000) = 5, number of digits =  5 + 1 = 6;

5. throw length_error();
   throw invalid_argument();

6. Use stack.emplace to push on to stack without basic data types.

Initializer Lists:
==================

1. Why should you using initializer list as opposed to normal initialization.
answer:
a) const data members: Must be initialized using initializer list
b) reference data members: int &a. Must be initialized using initializer list
c) initializing base class data members
if a Class A doesnt have a default constructor and it is a data member for class B, then class A must be initialized using initializer list in class B's constructor
class A
{
    A(int x){

    }
}

class B : A
{
  A a;
  B(int x): a(x){

  }

}
d) when constructor's parameter name is same as data member
e) Performance reasons


Trees :
======
1. A Full binary tree: All nodes except non leaf nodes have two children
Also all non leaf nodes in a full binary tree are one less than the leaf nodes.
(can be proved by induction)

2. Similarly a perfect binary tree contains a total of 2^(h+1) - 1 nodes.
h being the height. out of which 2^h are leaf nodes.

When traversing a tree recursively, time complexity is O(n)
But space complexity is O(h) because at any point maximum nodes stored on the system stack would be <= h.
